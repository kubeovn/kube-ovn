From 8b5084a55ca3f68f46530f43310ae2eae74322d2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=BC=A0=E7=A5=96=E5=BB=BA?= <zhangzujian.7@gmail.com>
Date: Tue, 15 Nov 2022 17:56:48 +0800
Subject: [PATCH] fix reaching resubmit limit in underlay

---
 northd/northd.c | 54 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/northd/northd.c b/northd/northd.c
index 73836758b2..c693e294ab 100644
--- a/northd/northd.c
+++ b/northd/northd.c
@@ -77,6 +77,8 @@ static bool use_ct_inv_match = true;
 
 static bool ls_dnat_mod_dl_dst = false;
 
+static bool bcast_arp_req_flood = true;
+
 #define MAX_OVN_TAGS 4096
 
 /* Pipeline stages. */
@@ -8044,6 +8046,10 @@ build_lswitch_flows(const struct hmap *datapaths,
             ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,
                           "outport == \"none\"",
                           "outport = \""MC_UNKNOWN "\"; output;");
+            if (!bcast_arp_req_flood) {
+                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 90,
+                              "eth.bcast && arp.op == 1", "next;");
+            }
         } else {
             ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,
                           "outport == \"none\"", "drop;");
@@ -8394,6 +8400,49 @@ build_lswitch_arp_nd_responder_default(struct ovn_datapath *od,
     }
 }
 
+/* Ingress table 18: forward ARP/ND request from localnet/vtep
+ * to logical switch port for known IPs.
+ * (priority 110)*/
+static void
+build_lswitch_arp_nd_forward_for_unknown_ips(struct ovn_port *op,
+                                             struct hmap *lflows,
+                                             struct ds *actions,
+                                             struct ds *match)
+{
+    if (bcast_arp_req_flood) {
+        return;
+    }
+    if (!op->od->nbs) {
+        return;
+    }
+    if (is_vlan_transparent(op->od)) {
+        return;
+    }
+
+    for (size_t i = 0; i < op->od->n_localnet_ports; i++) {
+        struct ovn_port *localnet_port = op->od->localnet_ports[i];
+        if (!localnet_port->nbsp) {
+            continue;
+        }
+
+        for (size_t j = 0; j < op->n_lsp_addrs; j++) {
+            for (size_t k = 0; k < op->lsp_addrs[j].n_ipv4_addrs; k++) {
+                ds_clear(match);
+                ds_put_format(match,
+                              "inport == %s && eth.bcast && "
+                              "arp.op == 1 && arp.tpa == %s",
+                              localnet_port->json_key,
+                              op->lsp_addrs[j].ipv4_addrs[k].addr_s);
+                ds_clear(actions);
+                ds_put_format(actions, "outport = %s; output;",
+                              op->json_key);
+                ovn_lflow_add(lflows, op->od, S_SWITCH_IN_ARP_ND_RSP, 110,
+                              ds_cstr(match), ds_cstr(actions));
+            }
+        }
+    }
+}
+
 /* Ingress table 18: ARP/ND responder for service monitor source ip.
  * (priority 110)*/
 static void
@@ -14098,6 +14147,9 @@ build_lswitch_and_lrouter_iterate_by_op(struct ovn_port *op,
                                              lsi->meter_groups,
                                              &lsi->actions,
                                              &lsi->match);
+    build_lswitch_arp_nd_forward_for_unknown_ips(op, lsi->lflows,
+                                                 &lsi->actions,
+                                                 &lsi->match);
     build_lswitch_dnat_mod_dl_dst_rules(op, lsi->lflows,
                                         lsi->ports,
                                         &lsi->actions,
@@ -15719,6 +15771,8 @@ ovnnb_db_run(struct northd_input *input_data,
                                           "use_logical_dp_groups", true);
     use_ct_inv_match = smap_get_bool(&nb->options,
                                      "use_ct_inv_match", true);
+    bcast_arp_req_flood = smap_get_bool(&nb->options,
+                                        "bcast_arp_req_flood", true);
 
     /* deprecated, use --event instead */
     controller_event_en = smap_get_bool(&nb->options,

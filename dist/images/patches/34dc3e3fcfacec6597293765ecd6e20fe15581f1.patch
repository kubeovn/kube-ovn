From 34dc3e3fcfacec6597293765ecd6e20fe15581f1 Mon Sep 17 00:00:00 2001
From: zhangzujian <zhangzujian.7@gmail.com>
Date: Thu, 10 Apr 2025 01:31:32 +0000
Subject: [PATCH] lflow: do not send direct traffic between lports to conntrack

Signed-off-by: zhangzujian <zhangzujian.7@gmail.com>
---
 northd/en-global-config.c |   5 ++
 northd/northd.c           | 104 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 109 insertions(+)

diff --git a/northd/en-global-config.c b/northd/en-global-config.c
index 6be1991330..6503239ed6 100644
--- a/northd/en-global-config.c
+++ b/northd/en-global-config.c
@@ -654,6 +654,11 @@ check_nb_options_out_of_sync(
         return true;
     }
 
+    if (config_out_of_sync(&nb->options, &config_data->nb_options,
+                           "ls_ct_skip_dst_lport_ips", false)) {
+        return true;
+    }
+
     return false;
 }
 
diff --git a/northd/northd.c b/northd/northd.c
index fe895ea151..4a7fdf80b9 100644
--- a/northd/northd.c
+++ b/northd/northd.c
@@ -103,6 +103,8 @@ static bool bcast_arp_req_flood = true;
 static struct sset node_local_dns_ip_v4 = SSET_INITIALIZER(&node_local_dns_ip_v4);
 static struct sset node_local_dns_ip_v6 = SSET_INITIALIZER(&node_local_dns_ip_v6);
 
+static bool ls_ct_skip_dst_lport_ips = false;
+
 #define MAX_OVN_TAGS 4096
 
 
@@ -6293,6 +6295,104 @@ build_ls_stateful_rec_pre_lb(const struct ls_stateful_record *ls_stateful_rec,
             free(match);
         }
         free(array);
+
+        if (!ls_ct_skip_dst_lport_ips) {
+            return;
+        }
+        if (od->n_router_ports != 1 && od->n_localnet_ports == 0) {
+            return;
+        }
+
+        ovs_be32 lla_ip4;
+        inet_pton(AF_INET, "169.254.0.0", &lla_ip4);
+        struct ovn_port *op;
+
+        if (od->n_router_ports == 1) {
+            struct ovn_port *peer = od->router_ports[0]->peer;
+            if (!peer || !peer->nbrp) {
+                return;
+            }
+
+            for (size_t i = 0; i < peer->od->n_router_ports; i++) {
+                op = peer->od->router_ports[i];
+                for (size_t j = 0; j < op->lrp_networks.n_ipv4_addrs; j++) {
+                    struct ipv4_netaddr *addrs;
+                    addrs = &op->lrp_networks.ipv4_addrs[j];
+                    if (addrs->plen >= 16 &&
+                        (addrs->addr & htonl(0xffff0000)) == lla_ip4) {
+                        // skip link local address
+                        continue;
+                    }
+                    match = xasprintf("ip4 && ip4.dst == %s/%u",
+                                      addrs->network_s, addrs->plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        &od->nbs->header_, lflow_ref);
+                    free(match);
+                }
+
+                for (size_t j = 0; j < op->lrp_networks.n_ipv6_addrs; j++) {
+                    struct ipv6_netaddr *addrs;
+                    addrs = &op->lrp_networks.ipv6_addrs[j];
+                    if (in6_is_lla(&addrs->network)) {
+                        // skip link local address
+                        continue;
+                    }
+                    match = xasprintf("ip6 && ip6.dst == %s/%u",
+                                      addrs->network_s, addrs->plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        &od->nbs->header_, lflow_ref);
+                    free(match);
+                }
+            }
+
+            return;
+        }
+
+        ovs_be32 ipv4;
+        struct in6_addr ipv6;
+        unsigned int plen;
+        char *error;
+        char buf[INET6_ADDRSTRLEN];
+
+        for (size_t i = 0; i < od->n_localnet_ports; i++) {
+            op = od->localnet_ports[i];
+            const char *ipv4_network = smap_get(&op->nbsp->external_ids,
+                                                "ipv4_network");
+            const char *ipv6_network = smap_get(&op->nbsp->external_ids,
+                                                "ipv6_network");
+            if (ipv4_network) {
+                error = ip_parse_cidr(ipv4_network, &ipv4, &plen);
+                if (error) {
+                    free(error);
+                    continue;
+                }
+                if (plen && plen != 32) {
+                    match = xasprintf("ip4 && ip4.dst == "IP_FMT"/%u",
+                                      IP_ARGS(ipv4), plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        &od->nbs->header_, lflow_ref);
+                    free(match);
+                }
+            }
+            if (ipv6_network) {
+                error = ipv6_parse_cidr(ipv6_network, &ipv6, &plen);
+                if (error) {
+                    free(error);
+                    continue;
+                }
+                if (plen && plen != 128) {
+                    inet_ntop(AF_INET6, &ipv6, buf, sizeof buf);
+                    match = xasprintf("ip6 && ip6.dst == %s/%u", buf, plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        &od->nbs->header_, lflow_ref);
+                    free(match);
+                }
+            }
+        }
     }
 }
 
@@ -19168,6 +19268,10 @@ ovnnb_db_run(struct northd_input *input_data,
     vxlan_mode = is_vxlan_mode(input_data->nb_options,
                                input_data->sbrec_chassis_table);
 
+    ls_ct_skip_dst_lport_ips = smap_get_bool(input_data->nb_options,
+                                             "ls_ct_skip_dst_lport_ips",
+                                             false);
+
     build_datapaths(ovnsb_txn,
                     input_data->nbrec_logical_switch_table,
                     input_data->nbrec_logical_router_table,

From 0f6fe4202001c0950dc689179e7a4ad9554a51fa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=BC=A0=E7=A5=96=E5=BB=BA?= <zhangzujian.7@gmail.com>
Date: Thu, 17 Nov 2022 10:25:52 +0800
Subject: [PATCH] fix reaching resubmit limit in underlay

---
 northd/ovn-northd.c | 54 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/northd/ovn-northd.c b/northd/ovn-northd.c
index 542c260792..b15468fa7e 100644
--- a/northd/ovn-northd.c
+++ b/northd/ovn-northd.c
@@ -102,6 +102,8 @@ static struct eth_addr svc_monitor_mac_ea;
  * Otherwise, it will avoid using it.  The default is true. */
 static bool use_ct_inv_match = true;
 
+static bool bcast_arp_req_flood = true;
+
 /* Default probe interval for NB and SB DB connections. */
 #define DEFAULT_PROBE_INTERVAL_MSEC 5000
 static int northd_probe_interval_nb = 0;
@@ -6860,6 +6862,10 @@ build_lswitch_flows(struct hmap *datapaths, struct hmap *lflows)
             ovn_lflow_add_unique(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,
                                  "outport == \"none\"",
                                  "outport = \""MC_UNKNOWN "\"; output;");
+            if (!bcast_arp_req_flood) {
+                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 90,
+                              "eth.bcast && arp.op == 1", "next;");
+            }
         } else {
             ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,
                           "outport == \"none\"", "drop;");
@@ -7122,6 +7128,49 @@ build_lswitch_arp_nd_responder_default(struct ovn_datapath *od,
     }
 }
 
+/* Ingress table 18: forward ARP/ND request from localnet/vtep
+ * to logical switch port for known IPs.
+ * (priority 110)*/
+static void
+build_lswitch_arp_nd_forward_for_unknown_ips(struct ovn_port *op,
+                                             struct hmap *lflows,
+                                             struct ds *actions,
+                                             struct ds *match)
+{
+    if (bcast_arp_req_flood) {
+        return;
+    }
+    if (!op->od->nbs) {
+        return;
+    }
+    if (is_vlan_transparent(op->od)) {
+        return;
+    }
+
+    for (size_t i = 0; i < op->od->n_localnet_ports; i++) {
+        struct ovn_port *localnet_port = op->od->localnet_ports[i];
+        if (!localnet_port->nbsp) {
+            continue;
+        }
+
+        for (size_t j = 0; j < op->n_lsp_addrs; j++) {
+            for (size_t k = 0; k < op->lsp_addrs[j].n_ipv4_addrs; k++) {
+                ds_clear(match);
+                ds_put_format(match,
+                              "inport == %s && eth.bcast && "
+                              "arp.op == 1 && arp.tpa == %s",
+                              localnet_port->json_key,
+                              op->lsp_addrs[j].ipv4_addrs[k].addr_s);
+                ds_clear(actions);
+                ds_put_format(actions, "outport = %s; output;",
+                              op->json_key);
+                ovn_lflow_add(lflows, op->od, S_SWITCH_IN_ARP_ND_RSP, 110,
+                              ds_cstr(match), ds_cstr(actions));
+            }
+        }
+    }
+}
+
 /* Ingress table 13: ARP/ND responder for service monitor source ip.
  * (priority 110)*/
 static void
@@ -11990,6 +12039,9 @@ build_lswitch_and_lrouter_iterate_by_op(struct ovn_port *op,
                                              lsi->ports,
                                              &lsi->actions,
                                              &lsi->match);
+    build_lswitch_arp_nd_forward_for_unknown_ips(op, lsi->lflows,
+                                                 &lsi->actions,
+                                                 &lsi->match);
     build_lswitch_dhcp_options_and_response(op, lsi->lflows);
     build_lswitch_external_port(op, lsi->lflows);
     build_lswitch_ip_unicast_lookup(op, lsi->lflows, lsi->mcgroups,
@@ -13345,6 +13397,8 @@ ovnnb_db_run(struct northd_context *ctx,
                                           "use_logical_dp_groups", false);
     use_ct_inv_match = smap_get_bool(&nb->options,
                                      "use_ct_inv_match", true);
+    bcast_arp_req_flood = smap_get_bool(&nb->options,
+                                        "bcast_arp_req_flood", true);
 
     /* deprecated, use --event instead */
     controller_event_en = smap_get_bool(&nb->options,

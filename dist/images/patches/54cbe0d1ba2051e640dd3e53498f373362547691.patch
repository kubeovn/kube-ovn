From 54cbe0d1ba2051e640dd3e53498f373362547691 Mon Sep 17 00:00:00 2001
From: zhangzujian <zhangzujian.7@gmail.com>
Date: Wed, 27 Mar 2024 06:12:18 +0000
Subject: [PATCH] lflow: do not send direct traffic between lports to conntrack

Signed-off-by: zhangzujian <zhangzujian.7@gmail.com>
---
 controller/lflow.c          |  11 +++
 controller/ovn-controller.c |  26 +++++-
 controller/ovn-controller.h |   2 +
 lib/ovn-util.h              |   3 +
 northd/northd.c             | 179 ++++++++++++++++++++++++++++++++++--
 5 files changed, 214 insertions(+), 7 deletions(-)

diff --git a/controller/lflow.c b/controller/lflow.c
index bef966a362..bbe966bd93 100644
--- a/controller/lflow.c
+++ b/controller/lflow.c
@@ -33,6 +33,7 @@
 #include "lib/lb.h"
 #include "lib/ovn-l7.h"
 #include "lib/ovn-sb-idl.h"
+#include "lib/ovn-util.h"
 #include "lib/extend-table.h"
 #include "lib/uuidset.h"
 #include "packets.h"
@@ -1078,6 +1079,16 @@ consider_logical_flow__(const struct sbrec_logical_flow *lflow,
         return;
     }
 
+    if (!lflow_kube_ovn_skip_ct) {
+        const char *hint = smap_get(&lflow->external_ids, "kube-ovn-hint");
+        if (hint && !strcmp(hint, OVN_LFLOW_HINT_KUBE_OVN_SKIP_CT)) {
+            VLOG_DBG("lflow "UUID_FMT
+                      " is not compatible with current kernel version, skip",
+                      UUID_ARGS(&lflow->header_.uuid));
+            return;
+        }
+    }
+
     const char *io_port = smap_get(&lflow->tags, "in_out_port");
     if (io_port) {
         objdep_mgr_add(l_ctx_out->lflow_deps_mgr, OBJDEP_TYPE_PORTBINDING,
diff --git a/controller/ovn-controller.c b/controller/ovn-controller.c
index 8b99e0e572..74915f5694 100644
--- a/controller/ovn-controller.c
+++ b/controller/ovn-controller.c
@@ -22,6 +22,7 @@
 #include <signal.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/utsname.h>
 
 #include "bfd.h"
 #include "binding.h"
@@ -83,6 +84,8 @@
 
 VLOG_DEFINE_THIS_MODULE(main);
 
+bool lflow_kube_ovn_skip_ct = false;
+
 static unixctl_cb_func ct_zone_list;
 static unixctl_cb_func extend_table_list;
 static unixctl_cb_func inject_pkt;
@@ -4092,6 +4095,25 @@ main(int argc, char *argv[])
     char *ovs_remote = parse_options(argc, argv);
     fatal_ignore_sigpipe();
 
+    errno = 0;
+    struct utsname info;
+    if (uname(&info)) {
+        perror("could not get kernel information");
+        exit(EXIT_FAILURE);
+    }
+
+    if (!strstr(info.release, "el8")) {
+        lflow_kube_ovn_skip_ct = true;
+    } else {
+        int kernel, major, minor, patch;
+        int n = sscanf(info.release, "%d.%d.%d-%d",
+                       &kernel, &major, &minor, &patch);
+        // RHEL 8.6 with kernel version 4.18.0-372 is not supported
+        if (n != 4 || kernel != 4 || major != 18 || minor != 0 || patch != 372) {
+            lflow_kube_ovn_skip_ct = true;
+        }
+    }
+
     daemonize_start(true);
 
     char *abs_unixctl_path = get_abs_unix_ctl_path(NULL);
@@ -4105,6 +4127,9 @@ main(int argc, char *argv[])
 
     daemonize_complete();
 
+    VLOG_INFO("kernel version is %s", info.release);
+    VLOG_INFO("lflow_kube_ovn_skip_ct is %s supported", lflow_kube_ovn_skip_ct ? "" : "not ");
+
     /* Register ofctrl seqno types. */
     ofctrl_seq_type_nb_cfg = ofctrl_seqno_add_type();
 
@@ -4201,7 +4226,6 @@ main(int argc, char *argv[])
      * */
 
     ovsdb_idl_omit(ovnsb_idl_loop.idl, &sbrec_sb_global_col_external_ids);
-    ovsdb_idl_omit(ovnsb_idl_loop.idl, &sbrec_logical_flow_col_external_ids);
     ovsdb_idl_omit(ovnsb_idl_loop.idl, &sbrec_port_binding_col_external_ids);
     ovsdb_idl_omit(ovnsb_idl_loop.idl, &sbrec_ssl_col_external_ids);
     ovsdb_idl_omit(ovnsb_idl_loop.idl,
diff --git a/controller/ovn-controller.h b/controller/ovn-controller.h
index 3a0e953775..6c80d81ec0 100644
--- a/controller/ovn-controller.h
+++ b/controller/ovn-controller.h
@@ -45,4 +45,6 @@ const struct ovsrec_bridge *get_bridge(const struct ovsrec_bridge_table *,
 
 uint32_t get_tunnel_type(const char *name);
 
+extern bool lflow_kube_ovn_skip_ct;
+
 #endif /* controller/ovn-controller.h */
diff --git a/lib/ovn-util.h b/lib/ovn-util.h
index fe50c00fab..053f08861a 100644
--- a/lib/ovn-util.h
+++ b/lib/ovn-util.h
@@ -28,6 +28,9 @@
 #define ROUTE_ORIGIN_CONNECTED "connected"
 #define ROUTE_ORIGIN_STATIC "static"
 
+#define OVN_LFLOW_HINT_KUBE_OVN_SKIP_CT \
+    "kube-ovn: skip conntrack for direct traffic between lports"
+
 #define ETH_CRC_LENGTH 4
 #define ETHERNET_OVERHEAD (ETH_HEADER_LEN + ETH_CRC_LENGTH)
 
diff --git a/northd/northd.c b/northd/northd.c
index 95e73e66ff..0a316cd631 100644
--- a/northd/northd.c
+++ b/northd/northd.c
@@ -88,6 +88,8 @@ static bool ls_dnat_mod_dl_dst = false;
 
 static bool bcast_arp_req_flood = true;
 
+static bool ls_ct_skip_dst_lport_ips = false;
+
 #define MAX_OVN_TAGS 4096
 
 /* Pipeline stages. */
@@ -5016,6 +5018,7 @@ struct ovn_lflow {
     char *actions;
     char *io_port;
     char *stage_hint;
+    char *kube_ovn_hint;
     char *ctrl_meter;
     struct ovn_dp_group *dpg;    /* Link to unique Sb datapath group. */
     const char *where;
@@ -5062,7 +5065,7 @@ static void
 ovn_lflow_init(struct ovn_lflow *lflow, struct ovn_datapath *od,
                enum ovn_stage stage, uint16_t priority,
                char *match, char *actions, char *io_port, char *ctrl_meter,
-               char *stage_hint, const char *where)
+               char *stage_hint, char *kube_ovn_hint, const char *where)
 {
     lflow->dpg_bitmap = bitmap_allocate(n_datapaths);
     lflow->od = od;
@@ -5072,6 +5075,7 @@ ovn_lflow_init(struct ovn_lflow *lflow, struct ovn_datapath *od,
     lflow->actions = actions;
     lflow->io_port = io_port;
     lflow->stage_hint = stage_hint;
+    lflow->kube_ovn_hint = kube_ovn_hint;
     lflow->ctrl_meter = ctrl_meter;
     lflow->dpg = NULL;
     lflow->where = where;
@@ -5158,6 +5162,7 @@ do_ovn_lflow_add(struct hmap *lflow_map, struct ovn_datapath *od,
                  uint32_t hash, enum ovn_stage stage, uint16_t priority,
                  const char *match, const char *actions, const char *io_port,
                  const struct ovsdb_idl_row *stage_hint,
+                 const char* kube_ovn_hint,
                  const char *where, const char *ctrl_meter)
 {
 
@@ -5179,7 +5184,9 @@ do_ovn_lflow_add(struct hmap *lflow_map, struct ovn_datapath *od,
                    xstrdup(match), xstrdup(actions),
                    io_port ? xstrdup(io_port) : NULL,
                    nullable_xstrdup(ctrl_meter),
-                   ovn_lflow_hint(stage_hint), where);
+                   ovn_lflow_hint(stage_hint),
+                   kube_ovn_hint ? xstrdup(kube_ovn_hint) : NULL,
+                   where);
     bitmap_set1(lflow->dpg_bitmap, od->index);
     if (parallelization_state != STATE_USE_PARALLELIZATION) {
         hmap_insert(lflow_map, &lflow->hmap_node, hash);
@@ -5199,6 +5206,7 @@ do_ovn_lflow_add_pd(struct hmap *lflow_map, struct ovn_datapath *od,
                     const char *match, const char *actions,
                     const char *io_port,
                     const struct ovsdb_idl_row *stage_hint,
+                    const char *kube_ovn_hint,
                     const char *where, const char *ctrl_meter)
 {
 
@@ -5208,7 +5216,8 @@ do_ovn_lflow_add_pd(struct hmap *lflow_map, struct ovn_datapath *od,
 
     ovs_mutex_lock(hash_lock);
     lflow = do_ovn_lflow_add(lflow_map, od, hash, stage, priority, match,
-                             actions, io_port, stage_hint, where, ctrl_meter);
+                             actions, io_port, stage_hint, kube_ovn_hint,
+                             where, ctrl_meter);
     ovs_mutex_unlock(hash_lock);
     return lflow;
 }
@@ -5226,11 +5235,12 @@ ovn_lflow_add_at_with_hash(struct hmap *lflow_map, struct ovn_datapath *od,
     ovs_assert(ovn_stage_to_datapath_type(stage) == ovn_datapath_get_type(od));
     if (parallelization_state == STATE_USE_PARALLELIZATION) {
         lflow = do_ovn_lflow_add_pd(lflow_map, od, hash, stage, priority,
-                                    match, actions, io_port, stage_hint, where,
-                                    ctrl_meter);
+                                    match, actions, io_port, stage_hint, NULL,
+                                    where, ctrl_meter);
     } else {
         lflow = do_ovn_lflow_add(lflow_map, od, hash, stage, priority, match,
-                         actions, io_port, stage_hint, where, ctrl_meter);
+                                 actions, io_port, stage_hint, NULL,
+                                 where, ctrl_meter);
     }
     return lflow;
 }
@@ -5253,6 +5263,36 @@ ovn_lflow_add_at(struct hmap *lflow_map, struct ovn_datapath *od,
                                io_port, ctrl_meter, stage_hint, where, hash);
 }
 
+static struct ovn_lflow *
+ovn_lflow_add_at_with_kube_ovn_hint(struct hmap *lflow_map,
+                                    struct ovn_datapath *od,
+                                    enum ovn_stage stage, uint16_t priority,
+                                    const char *match, const char *actions,
+                                    const char *io_port,
+                                    const char *ctrl_meter,
+                                    const char *kube_ovn_hint,
+                                    const char *where)
+{
+    uint32_t hash;
+    hash = ovn_logical_flow_hash(ovn_stage_get_table(stage),
+                                 ovn_stage_get_pipeline(stage),
+                                 priority, match,
+                                 actions);
+
+    struct ovn_lflow *lflow;
+    ovs_assert(ovn_stage_to_datapath_type(stage) == ovn_datapath_get_type(od));
+    if (parallelization_state == STATE_USE_PARALLELIZATION) {
+        lflow = do_ovn_lflow_add_pd(lflow_map, od, hash, stage, priority,
+                                    match, actions, io_port, NULL,
+                                    kube_ovn_hint, where, ctrl_meter);
+    } else {
+        lflow = do_ovn_lflow_add(lflow_map, od, hash, stage, priority, match,
+                                 actions, io_port, NULL, kube_ovn_hint,
+                                 where, ctrl_meter);
+    }
+    return lflow;
+}
+
 static void
 __ovn_lflow_add_default_drop(struct hmap *lflow_map,
                              struct ovn_datapath *od,
@@ -5275,6 +5315,12 @@ __ovn_lflow_add_default_drop(struct hmap *lflow_map,
     ovn_lflow_add_at(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, ACTIONS, \
                      NULL, NULL, STAGE_HINT, OVS_SOURCE_LOCATOR)
 
+#define ovn_lflow_add_with_kube_ovn_hint(LFLOW_MAP, OD, STAGE, PRIORITY, \
+                                         MATCH, ACTIONS, KUBE_OVN_HINT) \
+    ovn_lflow_add_at_with_kube_ovn_hint(LFLOW_MAP, OD, STAGE, PRIORITY, \
+                                        MATCH, ACTIONS, NULL, NULL, \
+                                        KUBE_OVN_HINT, OVS_SOURCE_LOCATOR)
+
 #define ovn_lflow_add_default_drop(LFLOW_MAP, OD, STAGE)                    \
     __ovn_lflow_add_default_drop(LFLOW_MAP, OD, STAGE, OVS_SOURCE_LOCATOR)
 
@@ -5335,6 +5381,9 @@ ovn_lflow_destroy(struct hmap *lflows, struct ovn_lflow *lflow)
         free(lflow->actions);
         free(lflow->io_port);
         free(lflow->stage_hint);
+        if (lflow->kube_ovn_hint) {
+            free(lflow->kube_ovn_hint);
+        }
         free(lflow->ctrl_meter);
         free(lflow);
     }
@@ -6087,6 +6136,110 @@ build_pre_lb(struct ovn_datapath *od, const struct shash *meter_groups,
                       100, "ip", REGBIT_CONNTRACK_NAT" = 1; next;");
         ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB,
                       100, "ip", REGBIT_CONNTRACK_NAT" = 1; next;");
+
+        if (!ls_ct_skip_dst_lport_ips) {
+            return;
+        }
+
+        if (!od->nbs) {
+            return;
+        }
+        if (od->n_router_ports != 1 && od->n_localnet_ports == 0) {
+            return;
+        }
+
+        ovs_be32 lla_ip4;
+        inet_pton(AF_INET, "169.254.0.0", &lla_ip4);
+        char *match = NULL;
+        struct ovn_port *op;
+
+        if (od->n_router_ports == 1) {
+            struct ovn_port *peer = od->router_ports[0]->peer;
+            if (!peer || !peer->nbrp) {
+                return;
+            }
+
+            LIST_FOR_EACH (op, dp_node, &peer->od->port_list) {
+                for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {
+                    struct ipv4_netaddr *addrs;
+                    addrs = &op->lrp_networks.ipv4_addrs[i];
+                    if (addrs->plen >= 16 &&
+                        (addrs->addr & htonl(0xffff0000)) == lla_ip4) {
+                        // skip link local address
+                        continue;
+                    }
+                    match = xasprintf("ip4 && ip4.dst == %s/%u",
+                                    addrs->network_s, addrs->plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        OVN_LFLOW_HINT_KUBE_OVN_SKIP_CT);
+                    free(match);
+                }
+
+                for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {
+                    struct ipv6_netaddr *addrs;
+                    addrs = &op->lrp_networks.ipv6_addrs[i];
+                    if (addrs->plen >= 10 &&
+                        (addrs->addr.s6_addr[0] & 0xff) == 0xfe &&
+                        (addrs->addr.s6_addr[1] & 0xc0) == 0x80) {
+                        // skip link local address
+                        continue;
+                    }
+                    match = xasprintf("ip6 && ip6.dst == %s/%u",
+                                    addrs->network_s, addrs->plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        OVN_LFLOW_HINT_KUBE_OVN_SKIP_CT);
+                    free(match);
+                }
+            }
+
+            return;
+        }
+
+        ovs_be32 ipv4;
+        struct in6_addr ipv6;
+        unsigned int plen;
+        char *error;
+        char buf[INET6_ADDRSTRLEN];
+
+        for (size_t i = 0; i < od->n_localnet_ports; i++) {
+            op = od->localnet_ports[i];
+            const char *ipv4_network = smap_get(&op->nbsp->external_ids,
+                                                "ipv4_network");
+            const char *ipv6_network = smap_get(&op->nbsp->external_ids,
+                                                "ipv6_network");
+            if (ipv4_network) {
+                error = ip_parse_cidr(ipv4_network, &ipv4, &plen);
+                if (error) {
+                    free(error);
+                    continue;
+                }
+                if (plen && plen != 32) {
+                    match = xasprintf("ip4 && ip4.dst == "IP_FMT"/%u",
+                                      IP_ARGS(ipv4), plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        OVN_LFLOW_HINT_KUBE_OVN_SKIP_CT);
+                    free(match);
+                }
+            }
+            if (ipv6_network) {
+                error = ipv6_parse_cidr(ipv6_network, &ipv6, &plen);
+                if (error) {
+                    free(error);
+                    continue;
+                }
+                if (plen && plen != 128) {
+                    inet_ntop(AF_INET6, &ipv6, buf, sizeof buf);
+                    match = xasprintf("ip6 && ip6.dst == %s/%u", buf, plen);
+                    ovn_lflow_add_with_kube_ovn_hint(lflows, od,
+                        S_SWITCH_IN_PRE_LB, 105, match, "next;",
+                        OVN_LFLOW_HINT_KUBE_OVN_SKIP_CT);
+                    free(match);
+                }
+            }
+        }
     }
 }
 
@@ -15384,6 +15537,8 @@ void build_lflows(struct lflow_input *input_data,
                                                   "stage-name", "");
                 const char *stage_hint = smap_get_def(&sbflow->external_ids,
                                                   "stage-hint", "");
+                const char *kube_ovn_hint = smap_get_def(&sbflow->external_ids,
+                                                         "kube-ovn-hint", "");
                 const char *source = smap_get_def(&sbflow->external_ids,
                                                   "source", "");
 
@@ -15397,6 +15552,12 @@ void build_lflows(struct lflow_input *input_data,
                         "stage-hint", lflow->stage_hint);
                     }
                 }
+                if (lflow->kube_ovn_hint) {
+                    if (strcmp(kube_ovn_hint, lflow->kube_ovn_hint)) {
+                        sbrec_logical_flow_update_external_ids_setkey(sbflow,
+                        "kube-ovn-hint", lflow->kube_ovn_hint);
+                    }
+                }
                 if (lflow->where) {
                     if (strcmp(source, lflow->where)) {
                         sbrec_logical_flow_update_external_ids_setkey(sbflow,
@@ -15500,6 +15661,9 @@ void build_lflows(struct lflow_input *input_data,
         if (lflow->stage_hint) {
             smap_add(&ids, "stage-hint", lflow->stage_hint);
         }
+        if (lflow->kube_ovn_hint) {
+            smap_add(&ids, "kube-ovn-hint", lflow->kube_ovn_hint);
+        }
         sbrec_logical_flow_set_external_ids(sbflow, &ids);
         smap_destroy(&ids);
 
@@ -16524,6 +16688,9 @@ ovnnb_db_run(struct northd_input *input_data,
                                               false);
     ls_dnat_mod_dl_dst = smap_get_bool(&nb->options,
                                        "ls_dnat_mod_dl_dst", false);
+    ls_ct_skip_dst_lport_ips = smap_get_bool(&nb->options,
+                                             "ls_ct_skip_dst_lport_ips",
+                                             false);
 
     build_chassis_features(input_data, &data->features);
 

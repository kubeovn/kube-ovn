/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	kubeovnv1 "github.com/kubeovn/kube-ovn/pkg/apis/kubeovn/v1"
	metav1 "k8s.io/client-go/applyconfigurations/meta/v1"
)

// DNSNameResolverResolvedNameApplyConfiguration represents a declarative configuration of the DNSNameResolverResolvedName type for use
// with apply.
//
// DNSNameResolverResolvedName describes the details of a resolved DNS name.
type DNSNameResolverResolvedNameApplyConfiguration struct {
	// conditions provide information about the state of the DNS name.
	// Known .status.conditions.type is: "Degraded".
	// "Degraded" is true when the last resolution failed for the DNS name,
	// and false otherwise.
	Conditions []metav1.ConditionApplyConfiguration `json:"conditions,omitempty"`
	// dnsName is the resolved DNS name matching the name field of DNSNameResolverSpec. This field can
	// store both regular and wildcard DNS names which match the spec.name field. When the spec.name
	// field contains a regular DNS name, this field will store the same regular DNS name after it is
	// successfully resolved. When the spec.name field contains a wildcard DNS name, each resolvedName.dnsName
	// will store the regular DNS names which match the wildcard DNS name and have been successfully resolved.
	// If the wildcard DNS name can also be successfully resolved, then this field will store the wildcard
	// DNS name as well.
	DNSName *kubeovnv1.DNSName `json:"dnsName,omitempty"`
	// resolvedAddresses gives the list of associated IP addresses and their corresponding TTLs and last
	// lookup times for the dnsName.
	ResolvedAddresses []DNSNameResolverResolvedAddressApplyConfiguration `json:"resolvedAddresses,omitempty"`
	// resolutionFailures keeps the count of how many consecutive times the DNS resolution failed
	// for the dnsName. If the DNS resolution succeeds then the field will be set to zero. Upon
	// every failure, the value of the field will be incremented by one. The details about the DNS
	// name will be removed, if the value of resolutionFailures reaches 5 and the TTL of all the
	// associated IP addresses have expired.
	ResolutionFailures *int32 `json:"resolutionFailures,omitempty"`
}

// DNSNameResolverResolvedNameApplyConfiguration constructs a declarative configuration of the DNSNameResolverResolvedName type for use with
// apply.
func DNSNameResolverResolvedName() *DNSNameResolverResolvedNameApplyConfiguration {
	return &DNSNameResolverResolvedNameApplyConfiguration{}
}

// WithConditions adds the given value to the Conditions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Conditions field.
func (b *DNSNameResolverResolvedNameApplyConfiguration) WithConditions(values ...*metav1.ConditionApplyConfiguration) *DNSNameResolverResolvedNameApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithConditions")
		}
		b.Conditions = append(b.Conditions, *values[i])
	}
	return b
}

// WithDNSName sets the DNSName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DNSName field is set to the value of the last call.
func (b *DNSNameResolverResolvedNameApplyConfiguration) WithDNSName(value kubeovnv1.DNSName) *DNSNameResolverResolvedNameApplyConfiguration {
	b.DNSName = &value
	return b
}

// WithResolvedAddresses adds the given value to the ResolvedAddresses field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ResolvedAddresses field.
func (b *DNSNameResolverResolvedNameApplyConfiguration) WithResolvedAddresses(values ...*DNSNameResolverResolvedAddressApplyConfiguration) *DNSNameResolverResolvedNameApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithResolvedAddresses")
		}
		b.ResolvedAddresses = append(b.ResolvedAddresses, *values[i])
	}
	return b
}

// WithResolutionFailures sets the ResolutionFailures field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ResolutionFailures field is set to the value of the last call.
func (b *DNSNameResolverResolvedNameApplyConfiguration) WithResolutionFailures(value int32) *DNSNameResolverResolvedNameApplyConfiguration {
	b.ResolutionFailures = &value
	return b
}
